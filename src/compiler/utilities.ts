namespace ts {
    export interface SynthesizedNode extends Node {
        leadingCommentRanges?: CommentRange[];
        trailingCommentRanges?: CommentRange[];
        startsOnNewLine: boolean;
    }

    export interface StringSymbolWriter extends SymbolWriter {
        string(): string;
    }

    export interface EmitFileNames {
        jsFilePath: string;
        sourceMapFilePath: string;
        declarationFilePath: string;
    }

    export declare function nodeIsMissing(node: Node);
    export declare function nodeIsPresent(node: Node);
    export declare function isLet(node: Node): boolean;
    export declare function isConst(node: Node): boolean;
    export declare function isStatement(n: Node): boolean;
    export declare const stringify: (value: any) => string;
    export declare function escapeString(s: string): string;
    export declare function isTypeNode(node: Node): boolean;
    export declare function isIntrinsicJsxName(name: string);
    export declare function isClassElement(n: Node): boolean;
    export declare function isExpression(node: Node): boolean;
    export declare function isStatementWithLocals(node: Node);
    export declare function isBlock(node: Node): node is Block;
    export declare function isDeclaration(node: Node): boolean;
    export declare function textSpanEnd(span: TextSpan): number;
    export declare let fullTripleSlashReferencePathRegEx: RegExp;
    export declare function isAmbientModule(node: Node): boolean;
    export declare function isFunctionBlock(node: Node): boolean;
    export declare function nodeIsDecorated(node: Node): boolean;
    export declare function getRootDeclaration(node: Node): Node;
    export declare function isKeyword(token: SyntaxKind): boolean;
    export declare function isJSDocConstructSignature(node: Node);
    export declare function hasQuestionToken(node: Node): boolean;
    export declare function getIndentString(level: number): string;
    export declare function convertToBase64(input: string): string;
    export declare function nodeIsSynthesized(node: Node): boolean;
    export declare function isDeclarationName(name: Node): boolean;
    export declare function isInJavaScriptFile(node: Node): boolean;
    export declare let fullTripleSlashAMDReferencePathRegEx: RegExp;
    export declare function nodeCanBeDecorated(node: Node): boolean;
    export declare function isSuperCallExpression(n: Node): boolean;
    export declare function isInAmbientContext(node: Node): boolean;
    export declare function isAsyncFunctionLike(node: Node): boolean;
    export declare function isPrologueDirective(node: Node): boolean;
    export declare function getJSDocTypeTag(node: Node): JSDocTypeTag;
    export declare function isSuperPropertyOrElementAccess(node: Node);
    export declare function nodeOrChildIsDecorated(node: Node): boolean;
    export declare function getSourceFileOfNode(node: Node): SourceFile;
    export declare function escapeNonAsciiCharacters(s: string): string;
    export declare function getCombinedNodeFlags(node: Node): NodeFlags;
    export declare function isConstEnumDeclaration(node: Node): boolean;
    export declare function isIdentifierName(node: Identifier): boolean;
    export declare function isExternalModule(file: SourceFile): boolean;
    export declare function isSourceFile(node: Node): node is SourceFile;
    export declare function isDeclarationFile(file: SourceFile): boolean;
    export declare function modifierToFlag(token: SyntaxKind): NodeFlags;
    export declare function escapeIdentifier(identifier: string): string;
    export declare function createSynthesizedNodeArray(): NodeArray<any>;
    export declare function isIdentifier(node: Node): node is Identifier;
    export declare function isFunctionLikeKind(kind: SyntaxKind): boolean;
    export declare function getJSDocReturnTag(node: Node): JSDocReturnTag;
    export declare function isDynamicName(name: DeclarationName): boolean;
    export declare function getExternalModuleName(node: Node): Expression;
    export declare function isAliasSymbolDeclaration(node: Node): boolean;
    export declare function isWatchSet(options: CompilerOptions): boolean;
    export declare function unescapeIdentifier(identifier: string): string;
    export declare function declarationNameToString(name: DeclarationName);
    export declare function getAncestor(node: Node, kind: SyntaxKind): Node;
    export declare function getSingleLineStringWriter(): StringSymbolWriter;
    export declare function isAssignmentOperator(token: SyntaxKind): boolean;
    export declare function isTemplateLiteralKind(kind: SyntaxKind): boolean;
    export declare function hasDynamicName(declaration: Declaration): boolean;
    export declare function getEnclosingBlockScopeContainer(node: Node): Node;
    export declare function nodeStartsNewLexicalEnvironment(n: Node): boolean;
    export declare function isExternalModuleAugmentation(node: Node): boolean;
    export declare function getJSDocTemplateTag(node: Node): JSDocTemplateTag;
    export declare function createTextWriter(newLine: String): EmitTextWriter;
    export declare function isSourceFileJavaScript(file: SourceFile): boolean;
    export declare function createDiagnosticCollection(): DiagnosticCollection;
    export declare function hasRestParameter(s: SignatureDeclaration): boolean;
    export declare function isBlockScopedContainerTopLevel(node: Node): boolean;
    export declare function isStringOrNumericLiteral(kind: SyntaxKind): boolean;
    export declare function isLeftHandSideExpression(expr: Expression): boolean;
    export declare function isExternalModuleImportEqualsDeclaration(node: Node);
    export declare function isAccessor(node: Node): node is AccessorDeclaration;
    export declare function getContainingClass(node: Node): ClassLikeDeclaration;
    export declare function isNumericLiteral(node: Node): node is NumericLiteral;
    export declare function isRestParameter(node: ParameterDeclaration): boolean;
    export declare function isBindingPattern(node: Node): node is BindingPattern;
    export declare function introducesArgumentsExoticObject(node: Node): boolean;
    export declare function getEmitScriptTarget(compilerOptions: CompilerOptions);
    export declare function isClassLike(node: Node): node is ClassLikeDeclaration;
    export declare function releaseStringWriter(writer: StringSymbolWriter): void;
    export declare function isExternalOrCommonJsModule(file: SourceFile): boolean;
    export declare function hasTypeScriptFileExtension(fileName: string): boolean;
    export declare function getLocalSymbolForExportDefault(symbol: Symbol): Symbol;
    export declare function isNodeDescendantOf(node: Node, ancestor: Node): boolean;
    export declare function isBlockOrCatchScoped(declaration: Declaration): boolean;
    export declare function getDefaultLibFileName(options: CompilerOptions): string;
    export declare function isNodeDescendentOf(node: Node, ancestor: Node): boolean;
    export declare function makeIdentifierFromModuleName(moduleName: string): string;
    export declare function isExternalModuleNameRelative(moduleName: string): boolean;
    export declare function isWellKnownSymbolSyntactically(node: Expression): boolean;
    export declare function getTextOfNode(node: Node, includeTrivia?: boolean): string;
    export declare function isLiteralExpression(node: Node): node is LiteralExpression;
    export declare function getContainingFunction(node: Node): FunctionLikeDeclaration;
    export declare function isFunctionLike(node: Node): node is FunctionLikeDeclaration;
    export declare function cloneEntityName(node: EntityName, parent?: Node): EntityName;
    export declare function isObjectLiteralMethod(node: Node): node is MethodDeclaration;
    export declare function getLiteralText(node: LiteralLikeNode, sourceFile: SourceFile);
    export declare function rangeIsOnSingleLine(range: TextRange, sourceFile: SourceFile);
    export declare function getPropertyNameForKnownSymbolName(symbolName: string): string;
    export declare function isEmptyObjectLiteralOrArrayLiteral(expression: Node): boolean;
    export declare function isGlobalScopeAugmentation(module: ModuleDeclaration): boolean;
    export declare function isParameterDeclaration(node: VariableLikeDeclaration): boolean;
    export declare function isGeneratedIdentifier(node: Node): node is GeneratedIdentifier;
    export declare function getSuperContainer(node: Node, includeFunctions: boolean): Node;
    export declare function getTokenPosOfNode(node: Node, sourceFile?: SourceFile): number;
    export declare function getEmitModuleKind(compilerOptions: CompilerOptions): ModuleKind;
    export declare function isRightSideOfQualifiedNameOrPropertyAccess(node: Node): boolean;
    export declare function getLineOfLocalPositionFromLineMap(lineMap: number[], pos: number);
    export declare function getErrorSpanForNode(sourceFile: SourceFile, node: Node): TextSpan;
    export declare function getThisContainer(node: Node, includeArrowFunctions: boolean): Node;
    export declare function getEntityNameFromTypeNode(node: TypeNode): EntityName | Expression;
    export declare function getLineOfLocalPosition(currentSourceFile: SourceFile, pos: number);
    export declare function getTextOfNodeFromSourceText(sourceText: string, node: Node): string;
    export declare function getDeclarationOfKind(symbol: Symbol, kind: SyntaxKind): Declaration;
    export declare function isParameterPropertyDeclaration(node: ParameterDeclaration): boolean;
    export declare function getDeclarationOfKind(symbol: Symbol, kind: SyntaxKind): Declaration;
    export declare function getNewLineCharacter(options: CompilerOptions | PrinterOptions): string;
    export declare function isExpressionWithTypeArgumentsInClassExtendsClause(node: Node): boolean;
    export declare function isElementAccessExpression(node: Node): node is ElementAccessExpression;
    export declare function getOriginalSourceFileOrBundle(sourceFileOrBundle: SourceFile | Bundle);
    export declare function getExternalModuleNameFromPath(host: EmitHost, fileName: string): string;
    export declare function getSpanOfTokenAtPosition(sourceFile: SourceFile, pos: number): TextSpan;
    export declare function getLeadingCommentRangesOfNode(node: Node, sourceFileOfNode: SourceFile);
    export declare function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;
    export declare function createSynthesizedNode(kind: SyntaxKind, startsOnNewLine?: boolean): Node;
    export declare function getSetAccessorTypeAnnotationNode(accessor: AccessorDeclaration): TypeNode;
    export declare function isInstantiatedModule(node: ModuleDeclaration, preserveConstEnums: boolean);
    export declare function getExternalModuleImportEqualsDeclarationExpression(node: Node): Expression;
    export declare function isIterationStatement(node: Node, lookInLabeledStatements: boolean): boolean;
    export declare function isThisTypePredicate(predicate: TypePredicate): predicate is ThisTypePredicate;
    export declare function getLeadingCommentRangesOfNodeFromText(node: Node, text: string): CommentRange[];
    export declare function getFirstConstructorWithBody(node: ClassLikeDeclaration): ConstructorDeclaration;
    export declare function forEachReturnStatement<T>(body: Block, visitor: (stmt: ReturnStatement) => T): T;
    export declare function getSourceFilesToEmit(host: EmitHost, targetSourceFile?: SourceFile): SourceFile[];
    export declare function getResolvedModule(sourceFile: SourceFile, moduleNameText: string): ResolvedModule;
    export declare function getSpecialPropertyAssignmentKind(expression: Node): SpecialPropertyAssignmentKind;
    export declare function isSupportedExpressionWithTypeArguments(node: ExpressionWithTypeArguments): boolean;
    export declare function forEachYieldExpression(body: Block, visitor: (expr: YieldExpression) => void): void;
    export declare function getOwnEmitOutputFilePath(sourceFile: SourceFile, host: EmitHost, extension: string);
    export declare function arrayIsEqualTo<T>(arr1: T[], arr2: T[], comparer?: (a: T, b: T) => boolean): boolean;
    export declare function isInternalModuleImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
    export declare function getSourceFilePathInNewDir(sourceFile: SourceFile, host: EmitHost, newDirPath: string);
    export declare function getCorrespondingJSDocParameterTag(parameter: ParameterDeclaration): JSDocParameterTag;
    export declare function shouldEmitToOwnFile(sourceFile: SourceFile, compilerOptions: CompilerOptions): boolean;
    export declare function isIdentifierTypePredicate(predicate: TypePredicate): predicate is IdentifierTypePredicate;
    export declare function rangeEndPositionsAreOnSameLine(range1: TextRange, range2: TextRange, sourceFile: SourceFile);
    export declare function getInterfaceBaseTypeNodes(node: InterfaceDeclaration): NodeArray<ExpressionWithTypeArguments>;
    export declare function getClassExtendsHeritageClauseElement(node: ClassLikeDeclaration): ExpressionWithTypeArguments;
    export declare function cloneNode<T extends Node>(node: T, location?: TextRange, flags?: NodeFlags, parent?: Node): T;
    export declare function rangeEndIsOnSameLineAsRangeStart(range1: TextRange, range2: TextRange, sourceFile: SourceFile);
    export declare function rangeStartPositionsAreOnSameLine(range1: TextRange, range2: TextRange, sourceFile: SourceFile);
    export declare function getAllAccessorDeclarations(declarations: NodeArray<Declaration>, accessor: AccessorDeclaration);
    export declare function isRequireCall(expression: Node, checkArgumentIsStringLiteral: boolean): expression is CallExpression;
    export declare function createDiagnosticForNodeFromMessageChain(node: Node, messageChain: DiagnosticMessageChain): Diagnostic;
    export declare function getSourceTextOfNodeFromSourceFile(sourceFile: SourceFile, node: Node, includeTrivia?: boolean): string;
    export declare function setResolvedModule(sourceFile: SourceFile, moduleNameText: string, resolvedModule: ResolvedModule): void;
    export declare function getClassImplementsHeritageClauseElements(node: ClassLikeDeclaration): NodeArray<ExpressionWithTypeArguments>;
    export declare function createDiagnosticForNode(node: Node, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): Diagnostic;
    export declare function writeCommentRange(text: string, lineMap: number[], writer: EmitTextWriter, comment: CommentRange, newLine: string): void;
    export declare function emitNewLineBeforeLeadingComments(lineMap: number[], writer: EmitTextWriter, node: TextRange, leadingComments: CommentRange[]): void;
    export declare function writeFile(host: EmitHost, diagnostics: DiagnosticCollection, fileName: string, data: string, writeByteOrderMark: boolean, sourceFiles?: SourceFile[]): void;
    export declare function forEachExpectedEmitFile(host: EmitHost, action: (emitFileNames: EmitFileNames, sourceFiles: SourceFile[], isBundledEmit: boolean) => void, targetSourceFile?: SourceFile);
    export declare function forEachEmittedFile(host: EmitHost, action: (emitFileNames: EmitFileNames, sourceFileOrBundle: SourceFile | Bundle, emitOnlyDtsFiles: boolean) => void, sourceFilesOrTargetSourceFile?: SourceFile[] | SourceFile, emitOnlyDtsFiles?: boolean);
    export declare function emitComments(text: string, lineMap: number[], writer: EmitTextWriter, comments: CommentRange[], trailingSeparator: boolean, newLine: string, writeComment: (text: string, lineMap: number[], writer: EmitTextWriter, comment: CommentRange, newLine: string) => void): void;
    export declare function emitDetachedComments(text: string, lineMap: number[], writer: EmitTextWriter, writeComment: (text: string, lineMap: number[], writer: EmitTextWriter, comment: CommentRange, newLine: string) => void, node: TextRange, newLine: string, removeComments: boolean): { nodePos: number, detachedCommentEndPos: number };
}